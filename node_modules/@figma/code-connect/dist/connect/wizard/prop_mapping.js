"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSignatureAndGeneratePropMapping = exports.generatePropMapping = exports.buildMatchableNamesMap = exports.MatchableNameTypes = exports.generateValueMapping = exports.PROPERTY_PLACEHOLDER = void 0;
const figma_rest_api_1 = require("../figma_rest_api");
const fast_fuzzy_1 = require("fast-fuzzy");
const logging_1 = require("../../common/logging");
const intrinsics_1 = require("../../connect/intrinsics");
const signature_extraction_1 = require("./signature_extraction");
const create_1 = require("../../react/create");
/**
 * Used when we should output a placeholder for an unknown value in prop mapping.
 */
exports.PROPERTY_PLACEHOLDER = 'PROPERTY_PLACEHOLDER';
const PROP_MINIMUM_MATCH_THRESHOLD = 0.8;
function generateValueMapping(propSignature, figmaPropDef) {
    const codeEnumOptions = propSignature.split(' | ').map((str) => str.substring(1, str.length - 1)); // remove quote marks
    const searcher = new fast_fuzzy_1.Searcher(figmaPropDef.variantOptions);
    return codeEnumOptions.reduce((valueMapping, codeEnumValue) => {
        const results = searcher.search(codeEnumValue, { returnMatchData: true });
        if (results.length && results[0].score > 0.5) {
            valueMapping[results[0].item] = codeEnumValue;
        }
        return valueMapping;
    }, {});
}
exports.generateValueMapping = generateValueMapping;
/**
 * Attempts to create a mapping between a code prop and figma prop.
 * These props have been matched by name and aren't guaranteed to
 * actually be related, so we return null if no suitable mapping
 */
function generateIntrinsic({ propSignature, figmaPropName: figmaPropNameWithNodeId, figmaPropDef, }) {
    const figmaPropName = stripNodeIdFromPropertyName(figmaPropNameWithNodeId);
    if (propSignature === 'string' && figmaPropDef.type === figma_rest_api_1.FigmaRestApi.ComponentPropertyType.Text) {
        return {
            kind: intrinsics_1.IntrinsicKind.String,
            args: {
                figmaPropName,
            },
        };
    }
    if (propSignature === 'false | true' &&
        (figmaPropDef.type === figma_rest_api_1.FigmaRestApi.ComponentPropertyType.Boolean ||
            (figmaPropDef.type === figma_rest_api_1.FigmaRestApi.ComponentPropertyType.Variant &&
                figmaPropDef.variantOptions?.length === 2 &&
                figmaPropDef.variantOptions?.every(create_1.isBooleanKind)))) {
        return {
            kind: intrinsics_1.IntrinsicKind.Boolean,
            args: {
                figmaPropName,
            },
        };
    }
    if (propSignature.includes(' | ') &&
        figmaPropDef.type === figma_rest_api_1.FigmaRestApi.ComponentPropertyType.Variant) {
        const valueMapping = generateValueMapping(propSignature, figmaPropDef);
        // Only valuable if some values were mapped
        if (Object.keys(valueMapping).length > 0) {
            return {
                kind: intrinsics_1.IntrinsicKind.Enum,
                args: {
                    figmaPropName,
                    valueMapping,
                },
            };
        }
    }
    return null;
}
function stripNodeIdFromPropertyName(propertyName) {
    return propertyName.replace(/#\d+:\d+/, '');
}
const DELIMITERS_REGEX = /[\s-_]/g;
var MatchableNameTypes;
(function (MatchableNameTypes) {
    MatchableNameTypes[MatchableNameTypes["Property"] = 0] = "Property";
    MatchableNameTypes[MatchableNameTypes["VariantValue"] = 1] = "VariantValue";
    // ChildLayer, // TODO
})(MatchableNameTypes || (exports.MatchableNameTypes = MatchableNameTypes = {}));
/**
 * Builds a map of all properties and enum values, indexed by matchable name.
 * @param componentPropertyDefinitions
 * @returns A map of {name: values[]}. Each value is an array to avoid
 * collisions between properties / enum values
 */
function buildMatchableNamesMap(componentPropertyDefinitions) {
    const matchableValues = {};
    function add(matchableStr, definition) {
        matchableValues[matchableStr] = matchableValues[matchableStr] || [];
        matchableValues[matchableStr].push(definition);
    }
    Object.entries(componentPropertyDefinitions || {}).forEach(([propName, propDef]) => {
        const matchableStr = stripNodeIdFromPropertyName(propName).replace(DELIMITERS_REGEX, '');
        add(matchableStr, {
            type: MatchableNameTypes.Property,
            name: propName,
        });
        if (propDef.type === figma_rest_api_1.FigmaRestApi.ComponentPropertyType.Variant) {
            propDef.variantOptions?.forEach((variantOption) => {
                const variantMatchableStr = variantOption.replace(DELIMITERS_REGEX, '');
                add(variantMatchableStr, {
                    type: MatchableNameTypes.VariantValue,
                    name: variantOption,
                    variantProperty: propName,
                });
            });
        }
    });
    return matchableValues;
}
exports.buildMatchableNamesMap = buildMatchableNamesMap;
function generatePropMapping({ componentPropertyDefinitions, signature, }) {
    const propMapping = {};
    const matchableNames = buildMatchableNamesMap(componentPropertyDefinitions);
    const searchSpace = Object.keys(matchableNames);
    const searcher = new fast_fuzzy_1.Searcher(searchSpace);
    function findBestMatch(matchData, { score, where }) {
        for (const nameMatches of matchData) {
            if (nameMatches.score < score) {
                return null;
            }
            const items = matchableNames[nameMatches.item];
            const match = items.find(where);
            if (match) {
                return match;
            }
        }
        return null;
    }
    for (const [propName, propSignatureWithOptionalModifier] of Object.entries(signature)) {
        const propSignature = propSignatureWithOptionalModifier.startsWith('?')
            ? propSignatureWithOptionalModifier.substring(1)
            : propSignatureWithOptionalModifier;
        const results = searcher.search(propName, { returnMatchData: true });
        if (results.length === 0) {
            continue;
        }
        /**
         * First, look for matching property names with compatible types
         */
        const matchingProperty = findBestMatch(results, {
            score: PROP_MINIMUM_MATCH_THRESHOLD,
            where: (item) => item.type === MatchableNameTypes.Property,
        });
        if (matchingProperty) {
            const { name: figmaPropName } = matchingProperty;
            const intrinsic = generateIntrinsic({
                propSignature,
                figmaPropName,
                figmaPropDef: componentPropertyDefinitions[figmaPropName],
            });
            if (intrinsic) {
                propMapping[propName] = intrinsic;
            }
        }
        /**
         * Then if no match AND a boolean prop, look for matching variant values, e.g:
         *
         * disabled: figma.enum('State', {
         *   Disabled: true,
         * })
         */
        if (!propMapping[propName] && propSignature === 'false | true') {
            const matchingProperty = findBestMatch(results, {
                score: PROP_MINIMUM_MATCH_THRESHOLD,
                where: (item) => item.type === MatchableNameTypes.VariantValue,
            });
            if (matchingProperty) {
                const { name: variantValue, variantProperty } = matchingProperty;
                if (!variantProperty) {
                    throw new Error('Expected variant property'); // satisfying TS
                }
                propMapping[propName] = {
                    kind: intrinsics_1.IntrinsicKind.Enum,
                    args: {
                        figmaPropName: variantProperty,
                        valueMapping: {
                            [variantValue]: true,
                        },
                    },
                };
            }
        }
    }
    return propMapping;
}
exports.generatePropMapping = generatePropMapping;
function extractSignatureAndGeneratePropMapping({ exportName, filepath, projectInfo, componentPropertyDefinitions, cmd, }) {
    let signature;
    try {
        signature = (0, signature_extraction_1.extractSignature)({
            nameToFind: exportName,
            sourceFilePath: filepath,
            projectInfo,
        });
        if (cmd.verbose && Object.keys(signature).length === 0) {
            logging_1.logger.warn(`No TS signature found for "${exportName}" in ${filepath}`);
        }
    }
    catch (e) {
        if (cmd.verbose) {
            logging_1.logger.warn(`Could not extract TS signature for "${exportName}" in ${filepath}`);
        }
        return {
            propMapping: undefined,
            signature: undefined,
        };
    }
    return {
        propMapping: generatePropMapping({
            componentPropertyDefinitions,
            signature,
        }),
        signature: signature,
    };
}
exports.extractSignatureAndGeneratePropMapping = extractSignatureAndGeneratePropMapping;
//# sourceMappingURL=prop_mapping.js.map